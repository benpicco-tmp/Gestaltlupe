<?xml version="1.0" encoding="utf-8"?>
<ParameterDict>
  <Entry Key="Border.Max.x" Value="0.289141506953528" />
  <Entry Key="Border.Max.y" Value="1.31239485645354" />
  <Entry Key="Border.Max.z" Value="0.925719521919999" />
  <Entry Key="Border.Min.x" Value="-1.43649934667025" />
  <Entry Key="Border.Min.y" Value="-0.413245997170234" />
  <Entry Key="Border.Min.z" Value="-0.799921331703777" />
  <Entry Key="Formula.Parameters.Angle1Mult" Value="1" />
  <Entry Key="Formula.Parameters.Angle1Rot" Value="1" />
  <Entry Key="Formula.Parameters.Angle1Type" Value="2" />
  <Entry Key="Formula.Parameters.Angle2Mult" Value="0" />
  <Entry Key="Formula.Parameters.Angle2Rot" Value="0" />
  <Entry Key="Formula.Parameters.Angle2Type" Value="0" />
  <Entry Key="Formula.Parameters.Angle3Mult" Value="0" />
  <Entry Key="Formula.Parameters.Angle3Rot" Value="0" />
  <Entry Key="Formula.Parameters.Angle3Type" Value="0" />
  <Entry Key="Formula.Parameters.Mult1" Value="1" />
  <Entry Key="Formula.Parameters.Mult2" Value="0" />
  <Entry Key="Formula.Parameters.Mult3" Value="0" />
  <Entry Key="Formula.Parameters.Power" Value="1" />
  <Entry Key="Formula.Static.Cycles" Value="34" />
  <Entry Key="Formula.Static.Formula" Value="-1" />
  <Entry Key="Formula.Static.jx" Value="0" />
  <Entry Key="Formula.Static.jy" Value="0" />
  <Entry Key="Formula.Static.jz" Value="0" />
  <Entry Key="Formula.Static.jzz" Value="0" />
  <Entry Key="Formula.Static.MinCycle" Value="0" />
  <Entry Key="Intern.Formula.Source" Value="&#xA;&#xA;        int gr = 20;&#xA;        public override void Init()&#xA;        {&#xA;            base.Init();&#xA;&#xA;            // Rotation Angle Corresponding Angle Type&#xA;            // 0: (1,0,0)&#xA;            // 1: (0,1,0);&#xA;            // 2: (0,0,1);&#xA;            // 3: Plane including  point (x,y,z) and line (0,0,0)+t(0,0,1);&#xA;            // 4: Plane including  point (x,y,z) and line (0,0,0)+t(0,1,0);&#xA;            // 5: Plane including  point (x,y,z) and line (0,0,0)+t(1,0,0);&#xA;&#xA;          &#xA;            mult1 = GetOrSetDouble(&quot;Mult1&quot;, 0, &quot;Multiplicator 1&quot;);&#xA;            mult2 = GetOrSetDouble(&quot;Angle1Mult&quot;, -1, &quot;Angle 1 Multiplicator&quot;);&#xA;            mult3 = GetOrSetDouble(&quot;Mult2&quot;, 2, &quot;Multiplicator 2&quot;);&#xA;            mult4 = GetOrSetDouble(&quot;Angle2Mult&quot;, 0, &quot;Angle 2 Multiplicator&quot;);&#xA;            mult5 = GetOrSetDouble(&quot;Mult3&quot;, 2, &quot;Multiplicator 3&quot;);&#xA;            mult6 = GetOrSetDouble(&quot;Angle3Mult&quot;, 0, &quot;Angle 3 Multiplicator&quot;);&#xA;            power = GetOrSetDouble(&quot;Power&quot;, 1, &quot;Power&quot;);&#xA;            angleType1 = (int)GetOrSetDouble(&quot;Angle1Type&quot;, 4, &quot;Angle 1 Type Values=(0,1,2,3,4,5)&quot;,false);&#xA;            Fractrace.Basic.ParameterDict.Current.SetValue(&quot;Formula.Parameters.Angle1Type.PARAMETERINFO.VIEW.FixedButtons&quot;, &quot;0 1 2 3 4 5&quot;, false);&#xA;            angleType2 = (int)GetOrSetDouble(&quot;Angle2Type&quot;, 1, &quot;Angle 2 Type Values=(0,1,2,3,4,5)&quot;,false);&#xA;            Fractrace.Basic.ParameterDict.Current.SetValue(&quot;Formula.Parameters.Angle2Type.PARAMETERINFO.VIEW.FixedButtons&quot;, &quot;0 1 2 3 4 5&quot;, false);&#xA;            angleType3 = (int)GetOrSetDouble(&quot;Angle3Type&quot;, 2, &quot;Angle 3 Type Values=(0,1,2,3,4,5)&quot;,false);&#xA;            Fractrace.Basic.ParameterDict.Current.SetValue(&quot;Formula.Parameters.Angle3Type.PARAMETERINFO.VIEW.FixedButtons&quot;, &quot;0 1 2 3 4 5&quot;, false);&#xA;            angleRotationType1 = (int)GetOrSetDouble(&quot;Angle1Rot&quot;, 2, &quot;Angle 1 Values=(0,1,2,3)&quot;,false);&#xA;            Fractrace.Basic.ParameterDict.Current.SetValue(&quot;Formula.Parameters.Angle1Rot.PARAMETERINFO.VIEW.FixedButtons&quot;, &quot;0 1 2 3&quot;, false);&#xA;            angleRotationType2 = (int)GetOrSetDouble(&quot;Angle2Rot&quot;, 0, &quot;Angle 2 Values=(0,1,2,3)&quot;,false);&#xA;            Fractrace.Basic.ParameterDict.Current.SetValue(&quot;Formula.Parameters.Angle2Rot.PARAMETERINFO.VIEW.FixedButtons&quot;, &quot;0 1 2 3&quot;, false);&#xA;            angleRotationType3 = (int)GetOrSetDouble(&quot;Angle3Rot&quot;, 0, &quot;Angle 3 Values=(0,1,2,3)&quot;,false);&#xA;            Fractrace.Basic.ParameterDict.Current.SetValue(&quot;Formula.Parameters.Angle3Rot.PARAMETERINFO.VIEW.FixedButtons&quot;, &quot;0 1 2 3&quot;, false);&#xA;&#xA;        }&#xA;&#xA;        double mult1 = 0;&#xA;        double mult2 = 0;&#xA;        double mult3 = 0;&#xA;        double mult4 = 0;&#xA;        double mult5 = 0;&#xA;        double mult6 = 0;&#xA;        double power = 0;&#xA;        int angleType1 = 0;&#xA;        int angleType2 = 0;&#xA;        int angleType3 = 0;&#xA;        int angleRotationType1 = 0;&#xA;        int angleRotationType2 = 0;&#xA;        int angleRotationType3 = 0;&#xA;&#xA;&#xA;        public override long InSet(double x, double y, double z, double br, double bi, double bj, double bk, long zkl, bool invers)&#xA;        {&#xA;&#xA;            double xx, yy, zz;&#xA;            long tw;&#xA;            int n;&#xA;            xx = x * x; yy = y * y; zz = z * z;&#xA;            tw = 0;&#xA;            double r = Math.Sqrt(xx + yy + zz);&#xA;            Fractrace.Geometry.VecRotation vecRot = new Fractrace.Geometry.VecRotation();&#xA;&#xA;            double phi = 0;&#xA;            double phi2 = 0;&#xA;            double phi3 = 0;&#xA;&#xA;            Fractrace.Geometry.Vec3 pos = null;&#xA;            Fractrace.Geometry.Vec3 newPos = null;&#xA;&#xA;            additionalPointInfo.red = 0;&#xA;            additionalPointInfo.green = 0;&#xA;            additionalPointInfo.blue = 0;&#xA;            for (n = 1; n &lt; zkl; n++)&#xA;            {&#xA;&#xA;&#xA;                // **********************************&#xA;                // 1. Rotation&#xA;                // *************************************&#xA;&#xA;                phi = Math.Atan2(y, x);&#xA;                phi2 = Math.Atan2(y, z);&#xA;                phi3 = Math.Atan2(z, x);&#xA;&#xA;                if (mult2 != 0)&#xA;                {&#xA;&#xA;                    switch (angleType1)&#xA;                    {&#xA;&#xA;                        case 0:&#xA;                            vecRot.X = 1;&#xA;                            vecRot.Y = 0;&#xA;                            vecRot.Z = 0;&#xA;                            break;&#xA;&#xA;                        case 1:&#xA;                            vecRot.X = 0;&#xA;                            vecRot.Y = 1;&#xA;                            vecRot.Z = 0;&#xA;                            break;&#xA;&#xA;                        case 2:&#xA;                            vecRot.X = 0;&#xA;                            vecRot.Y = 0;&#xA;                            vecRot.Z = 1;&#xA;                            break;&#xA;&#xA;                        case 3:&#xA;                            vecRot.Y = -Math.Sin(mult1 * phi2);&#xA;                            vecRot.X = 0;&#xA;                            vecRot.Z = -Math.Cos(mult1 * phi2);&#xA;                            break;&#xA;&#xA;                        case 4:&#xA;                            vecRot.X = -Math.Sin(mult1 * phi);&#xA;                            vecRot.Y = -Math.Cos(mult1 * phi);&#xA;                            vecRot.Z = 0;&#xA;                            break;&#xA;&#xA;                        case 5:&#xA;                            vecRot.Y = 0;&#xA;                            vecRot.X = -Math.Sin(mult1 * phi3); ;&#xA;                            vecRot.Z = -Math.Cos(mult1 * phi3);&#xA;                            break;&#xA;&#xA;                    }&#xA;&#xA;                    switch (angleRotationType1)&#xA;                    {&#xA;                        case 0:&#xA;                            vecRot.Angle = 0;&#xA;                            break;&#xA;&#xA;                        case 1:&#xA;                            vecRot.Angle = mult2 * phi;&#xA;                            break;&#xA;&#xA;                        case 2:&#xA;                            vecRot.Angle = mult2 * phi2;&#xA;                            break;&#xA;&#xA;                        case 3:&#xA;                            vecRot.Angle = mult2 * phi3;&#xA;                            break;&#xA;&#xA;                    }&#xA;&#xA;&#xA;                    vecRot.Normalize();&#xA;                    pos = new Fractrace.Geometry.Vec3(x, y, z);&#xA;                    newPos = vecRot.getTransform(pos);&#xA;                    x = newPos.X;&#xA;                    y = newPos.Y;&#xA;                    z = newPos.Z;&#xA;                    xx = x * x; yy = y * y; zz = z * z;&#xA;                    r = 1;&#xA;&#xA;                    if (power == 0)&#xA;                    {&#xA;                        r = 1;&#xA;                    }&#xA;                    else if (power == 0.5)&#xA;                    {&#xA;                        r = Math.Sqrt(xx + yy + zz);&#xA;                    }&#xA;                    else if (power == 1)&#xA;                    {&#xA;                        r = xx + yy + zz;&#xA;                    }&#xA;                    else {&#xA;                        r = Math.Pow(xx + yy + zz, power);&#xA;                    }&#xA;&#xA;                    x *= r;&#xA;                    y *= r;&#xA;                    z *= r;&#xA;                }&#xA;&#xA;&#xA;&#xA;                // *********************************&#xA;                // 2. Rotation&#xA;                // *************************************&#xA;&#xA;&#xA;                if (mult4 != 0)&#xA;                {&#xA;&#xA;                    phi = Math.Atan2(z, x);&#xA;                    phi2 = Math.Atan2(z, y);&#xA;                    phi3 = Math.Atan2(z, x);&#xA;&#xA;                    switch (angleType2)&#xA;                    {&#xA;&#xA;                        case 0:&#xA;                            vecRot.X = 1;&#xA;                            vecRot.Y = 0;&#xA;                            vecRot.Z = 0;&#xA;                            break;&#xA;&#xA;                        case 1:&#xA;                            vecRot.X = 0;&#xA;                            vecRot.Y = 1;&#xA;                            vecRot.Z = 0;&#xA;                            break;&#xA;&#xA;                        case 2:&#xA;                            vecRot.X = 0;&#xA;                            vecRot.Y = 0;&#xA;                            vecRot.Z = 1;&#xA;                            break;&#xA;&#xA;                        case 3:&#xA;                            vecRot.Y = -Math.Sin(mult3 * phi2);&#xA;                            vecRot.X = 0;&#xA;                            vecRot.Z = -Math.Cos(mult3 * phi2);&#xA;                            break;&#xA;&#xA;                        case 4:&#xA;                            vecRot.X = -Math.Sin(mult3 * phi);&#xA;                            vecRot.Y = -Math.Cos(mult3 * phi);&#xA;                            vecRot.Z = 0;&#xA;                            break;&#xA;&#xA;                        case 5:&#xA;                            vecRot.Y = 0;&#xA;                            vecRot.X = -Math.Sin(mult3 * phi3); ;&#xA;                            vecRot.Z = -Math.Cos(mult3 * phi3);&#xA;                            break;&#xA;&#xA;                    }&#xA;&#xA;                    switch (angleRotationType2)&#xA;                    {&#xA;                        case 0:&#xA;                            vecRot.Angle = 0;&#xA;                            break;&#xA;&#xA;                        case 1:&#xA;                            vecRot.Angle = mult4 * phi;&#xA;                            break;&#xA;&#xA;                        case 2:&#xA;                            vecRot.Angle = mult4 * phi2;&#xA;                            break;&#xA;&#xA;                        case 3:&#xA;                            vecRot.Angle = mult4 * phi3;&#xA;                            break;&#xA;&#xA;                    }&#xA;&#xA;&#xA;&#xA;                    vecRot.Normalize();&#xA;                    pos = new Fractrace.Geometry.Vec3(x, y, z);&#xA;                    newPos = vecRot.getTransform(pos);&#xA;                    x = newPos.X;&#xA;                    y = newPos.Y;&#xA;                    z = newPos.Z;&#xA;                    xx = x * x; yy = y * y; zz = z * z;&#xA;&#xA;&#xA;                    r = 1;&#xA;&#xA;&#xA;                    if (power == 0)&#xA;                    {&#xA;                        r = 1;&#xA;                    }&#xA;                    else if (power == 0.5)&#xA;                    {&#xA;                        r = Math.Sqrt(xx + yy + zz);&#xA;                    }&#xA;                    else if (power == 1)&#xA;                    {&#xA;                        r = xx + yy + zz;&#xA;                    }&#xA;                    else {&#xA;                        r = Math.Pow(xx + yy + zz, power);&#xA;                    }&#xA;&#xA;                    x *= r;&#xA;                    y *= r;&#xA;                    z *= r;&#xA;                }&#xA;&#xA;&#xA;                // ***********************************&#xA;                // 3. Rotation&#xA;                // ***********************************&#xA;&#xA;                if (mult6 != 0)&#xA;                {&#xA;&#xA;                    phi = Math.Atan2(z, y);&#xA;                    phi2 = Math.Atan2(z, x);&#xA;&#xA;&#xA;                    phi3 = Math.Atan2(z, x);&#xA;&#xA;                    switch (angleType3)&#xA;                    {&#xA;&#xA;                        case 0:&#xA;                            vecRot.X = 1;&#xA;                            vecRot.Y = 0;&#xA;                            vecRot.Z = 0;&#xA;                            break;&#xA;&#xA;                        case 1:&#xA;                            vecRot.X = 0;&#xA;                            vecRot.Y = 1;&#xA;                            vecRot.Z = 0;&#xA;                            break;&#xA;&#xA;                        case 2:&#xA;                            vecRot.X = 0;&#xA;                            vecRot.Y = 0;&#xA;                            vecRot.Z = 1;&#xA;                            break;&#xA;&#xA;                        case 3:&#xA;                            vecRot.Y = -Math.Sin(mult5 * phi2);&#xA;                            vecRot.X = 0;&#xA;                            vecRot.Z = -Math.Cos(mult5 * phi2);&#xA;                            break;&#xA;&#xA;                        case 4:&#xA;                            vecRot.X = -Math.Sin(mult5 * phi);&#xA;                            vecRot.Y = -Math.Cos(mult5 * phi);&#xA;                            vecRot.Z = 0;&#xA;                            break;&#xA;&#xA;                        case 5:&#xA;                            vecRot.Y = 0;&#xA;                            vecRot.X = -Math.Sin(mult5 * phi3); ;&#xA;                            vecRot.Z = -Math.Cos(mult5 * phi3);&#xA;                            break;&#xA;&#xA;                    }&#xA;&#xA;                    switch (angleRotationType3)&#xA;                    {&#xA;                        case 0:&#xA;                            vecRot.Angle = 0;&#xA;                            break;&#xA;&#xA;                        case 1:&#xA;                            vecRot.Angle = mult6 * phi;&#xA;                            break;&#xA;&#xA;                        case 2:&#xA;                            vecRot.Angle = mult6 * phi2;&#xA;                            break;&#xA;&#xA;                        case 3:&#xA;                            vecRot.Angle = mult6 * phi3;&#xA;                            break;&#xA;&#xA;                    }&#xA;&#xA;&#xA;&#xA;                    vecRot.Normalize();&#xA;                    pos = new Fractrace.Geometry.Vec3(x, y, z);&#xA;                    newPos = vecRot.getTransform(pos);&#xA;                    x = newPos.X;&#xA;                    y = newPos.Y;&#xA;                    z = newPos.Z;&#xA;                    xx = x * x; yy = y * y; zz = z * z;&#xA;&#xA;                    r = 1;&#xA;                    if (power == 0)&#xA;                    {&#xA;                        r = 1;&#xA;                    }&#xA;                    else if (power == 0.5)&#xA;                    {&#xA;                        r = Math.Sqrt(xx + yy + zz);&#xA;                    }&#xA;                    else if (power == 1)&#xA;                    {&#xA;                        r = xx + yy + zz;&#xA;                    }&#xA;                    else {&#xA;                        r = Math.Pow(xx + yy + zz, power);&#xA;                    }&#xA;&#xA;                    x *= r;&#xA;                    y *= r;&#xA;                    z *= r;&#xA;                }&#xA;&#xA;                // Rotation ends:&#xA;&#xA;&#xA;                y += bj;&#xA;                x += br;&#xA;                z += bi;&#xA;&#xA;                if (r != 0)&#xA;                {&#xA;                    additionalPointInfo.red += xx / r;&#xA;                    additionalPointInfo.green += yy / r;&#xA;                    additionalPointInfo.blue += zz / r;&#xA;                }&#xA;&#xA;&#xA;                if (r &gt; gr)&#xA;                {&#xA;                    tw = n; break;&#xA;                }&#xA;            }&#xA;&#xA;&#xA;            // Switch inner and outer view&#xA;            if (invers)&#xA;            {&#xA;                if (tw == 0)&#xA;                    tw = 1;&#xA;                else&#xA;                    tw = 0;&#xA;            }&#xA;            return (tw);&#xA;        }&#xA;&#xA;" />
  <Entry Key="Transformation.Camera.AngleX" Value="0" />
  <Entry Key="Transformation.Camera.AngleY" Value="0" />
  <Entry Key="Transformation.Camera.AngleZ" Value="0" />
  <Entry Key="Transformation.Perspective.Cameraposition" Value="1" />
  <Entry Key="Transformation.Stereo.Angle" Value="-9" />
  <Entry Key="Transformation.Stereo.EyeDistance" Value="0.5" />
  <Entry Key="View.Height" Value="1200" />
  <Entry Key="View.Perspective" Value="1" />
  <Entry Key="View.Width" Value="1200" />
</ParameterDict>
<?xml version="1.0" encoding="utf-8"?>
<book id="book" lang="de">
  <bookinfo>
    <title>Book</title>
  </bookinfo>
  <!--
  <part>
    <title>Introduction</title>
    
    <para>
Gestaltlupe is a scientific tool to render tomographic functions. 
A tomographic function <emphasis branch="">T(p)</emphasis> (<emphasis branch="">p</emphasis> is a point <emphasis branch="">p=(x,y,z)</emphasis> in <emphasis branch="">R^3</emphasis>) returns either <emphasis branch="">true</emphasis> or <emphasis branch="">false</emphasis>. The rendering 
interpreted this as formula description of an arbitrary object in the 3D space. This means: <emphasis branch="">T(p)=true</emphasis>, 
if and only if <emphasis branch="">p</emphasis> is inside the object. </para>
    <para>
Double click on <application branch="">Gestaltlupe_1_0_2.exe</application> , choose Tab <emphasis branch="">file</emphasis>, load an sample project and press the 
button “preview” to get after a short time a small picture of the given 3D object, or press "start" 
to render a bitmap in full resolution. </para>
  </part>
  <part>
    <title>Install</title>



<para>Gestaltlupe is available at GitHub at:

<ulink url="" branch="">http://github.com/trafassel/Gestaltlupe </ulink>
   
The corresponding Version 1.0.2, which is documented here, can be found at:

<ulink url="" branch="">http://github.com/trafassel/Gestaltlupe/blob/master/bin/Gestaltlupe_1_0_2.exe </ulink>

On this page you have to click “raw” to get the binary.  But the recommended way to work with 
Gestaltlupe is to download the full archive file (the big “Download” button at 
<ulink url="" branch="">http://github.com/trafassel/Gestaltlupe </ulink>). The archive contains the binaries and sample projects 
with the corresponding formulas.
</para>
    <para />
    <chapter>
      <title>Windows</title>
      <para>
Gestaltlupe is developed and tested with WindowsXP and Windows7. It is a native .NET 2.0 application. </para>
    </chapter>
    <chapter>
      <title>Linux</title>
      <para>To run Gestaltlupe  on a Linux system, you have to install the mono package 
(<ulink url="" branch="">http://www.mono-project.com/Main_Page </ulink>). It is tested on a Ubuntu Hardy Heron 8.04.3 LTS. 
It runs without problems, but looks more ugly than the windows version (Yes, that is possible).</para>
    </chapter>
    <chapter>
      <title>Mac OSX</title>
      <para>
It is tested on a Mac OSX 10.6. with Mono 2.8 . It can produce some nice pictures, but working is a 
pain, because some windows forms are not redrawn properly (Gestaltlupe is compatible to the 
Windows.Forms library 2.0).</para>
    </chapter>
  </part>
  -->
  <part>
    <title>Introduction</title>
    <para>Gestaltlupe is a scientific tool to render <link linkend="tomographicfunction" branch="">tomographic functions</link>.
    
    </para>
    <para>
    </para>
    <para>
      Double click on <application branch="">Gestaltlupe_1_2_0.exe</application> , choose Tab <emphasis branch="">file</emphasis>, load an sample project and press the
      button “preview” to get after a short time a small picture of the given 3D object, or press "start"
      to render a bitmap in full resolution.
    </para>
    <chapter>
      <title>Install</title>
      <para>
      Gestaltlupe is available at GitHub at:

      <ulink url="http://github.com/trafassel/Gestaltlupe">http://github.com/trafassel/Gestaltlupe </ulink>

      The corresponding Version 1.2.0, which is documented here, can be found at:

      <ulink url="http://github.com/trafassel/Gestaltlupe/blob/master/bin/Gestaltlupe_1_2_0.exe">http://github.com/trafassel/Gestaltlupe/blob/master/bin/Gestaltlupe_1_2_0.exe </ulink>

      On this page you have to click “raw” to get the binary.  But the recommended way to work with
      Gestaltlupe is to download the full archive file (the big “Download” button at
      <ulink url="http://github.com/trafassel/Gestaltlupe" branch="">http://github.com/trafassel/Gestaltlupe </ulink>). The archive contains the binaries and sample projects
      with the corresponding formulas and this documentation.
    </para>
      <para />
      <section>
        <title>Windows</title>
        <para>
        Gestaltlupe is developed and tested with WindowsXP and Windows7. It is a native .NET 2.0 application.
      </para>
      </section>
      <section>
        <title>Linux</title>
        <para>
        To run Gestaltlupe  on a Linux system, you have to install the mono package
        (<ulink url="" branch="">http://www.mono-project.com/Main_Page </ulink>). It is tested on a Ubuntu Hardy Heron 8.04.3 LTS.
        It runs without problems, but looks more ugly than the windows version.
      </para>
      </section>
      <section>
        <title>Mac OSX</title>
        <para>
        It is tested on a Mac OSX 10.6. with Mono 2.8 . It can produce some nice pictures, but working is a
        pain, because some windows forms are not redrawn properly (Gestaltlupe is compatible to the
        Windows.Forms library 2.0).
      </para>
      </section>
    </chapter>
    <chapter>
      <title>Getting Started</title>
      <para>Gestaltlupe starts in navigation mode.</para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/MainWindow.png" />
      </imageobject>
      <para>The default tomographic formula is the Mandelbulb. If you click on the left square in the bottom frame, you get a small overview of the defined scene.</para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/Preview1.png" />
      </imageobject>
      <para>If the overview looks good, the user can press the button <emphasis branch="">Preview</emphasis> to draw the scene as bigger preview in a separate window. </para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/Preview2.png" />
      </imageobject>
      <para>This picture is saved automatically in the file, defined at the top of the render window. The corresponding settings are saved with the same name, but with the ending <application branch="">*.tomo</application> in the path <emphasis branch="">Userpath</emphasis><application branch="">/Documents/TomoTrace/data/parameters</application>. So you are always able to open the settings for a generated picture. </para>
      <para>The final rendering starts after click on the button <emphasis branch="">Start</emphasis> in the main window.</para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/Output1.png" />
      </imageobject>
      <para />
    </chapter>
  </part>
  <part>
    <title>Interface Description</title>
    <para>If you want to improve the quality of the rendering result, you have to read the chapter <link linkend="rendering" branch="">Rendering</link>. </para>
    <para>Or you want to see, what is inside the tunnel or rotate and zoom the whole object.
The chapter <link linkend="navigation">Navigation</link> describes, how to navigate in the virtual 3D space.</para>
    <para>If you want to define another fractal, then you have to read the chapter <link linkend="formula">Formula</link>.  </para>
    <para>If you are completed your study in navigation or formula description, you are ready for your first <link linkend="animation">animation</link>. </para>
    <chapter id="rendering">
      <title>Rendering</title>
      <para>Rendering is a 2 stage process. 

In the first stage the geometry is generated. The geometry data for each pixel of the resulting bitmap contains:

<itemizedlist branch=""><listitem>the exact coordinates of the corresponding surface point</listitem><listitem>the normal of the surface at this point</listitem><listitem>and (eventually) the surface color</listitem></itemizedlist></para>
      <para>
In the second stage the renderer generates the bitmap from the geometry data . Because the renderer got only informations of the visible points, the ability to generate a cinema like raytracing picture is limited. </para>
      <para>
The first stage used multiple threads. This means, the computation is done on multiple processors. 
The second stage runs in one thread, uses only one processor and blocks the whole application.</para>
      <para>The rendering parameters can be set in the <emphasis branch="">Data</emphasis> tab at <link linkend="composite">Renderer</link> </para>
    </chapter>
    <chapter id="navigation">
      <title>Navigation</title>
      <para>The area in 3D space, which will be used for the rendering of the 3D object is defined in the <link linkend="parameter.border">border</link> parameters. The monitor plane corresponds to  <emphasis branch="">(x,z)</emphasis> and the direction of the y-axis is the depth.   </para>
      <para>The camera settings (i.e. rotations) are given in <link linkend="parameter.transformation">Transformation</link>. Some of this parameters can be manipulated in the navigation control.</para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/Navigate.png" />
      </imageobject>
      <para>If you press one of the buttons, the small preview control at the bottom is redrawn automatically, but you don't have to wait for completing the picture.  I.e. defining a factor value of 12 and double pressing of <emphasis branch="">left</emphasis> (&lt;-) is the same as factor=6 and pressing <emphasis branch="">left</emphasis> just one time.</para>
      <para>Using one of the buttons <emphasis branch="">ZoomX</emphasis>, ...  <emphasis branch="">ZoomZOut</emphasis> results in a broken screen aspect. To correct the x/z ratio, you have to press the button <emphasis branch="">Automatic</emphasis>.</para>
      <table>
        <title>
        </title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Symbol</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&gt; &lt;</entry>
              <entry>move forward</entry>
            </row>
            <row>
              <entry>&lt;&gt;</entry>
              <entry>move back</entry>
            </row>
            <row>
              <entry>/\</entry>
              <entry>move up</entry>
            </row>
            <row>
              <entry>\/</entry>
              <entry>move down</entry>
            </row>
            <row>
              <entry>&lt;-</entry>
              <entry>move left</entry>
            </row>
            <row>
              <entry>-&gt;</entry>
              <entry>move right</entry>
            </row>
            <row>
              <entry>+</entry>
              <entry>zoom in</entry>
            </row>
            <row>
              <entry>-</entry>
              <entry>zoom out</entry>
            </row>
            <row>
              <entry>RotX (+,-)</entry>
              <entry>Add the given angle (in degree) to the rotation in the (1,0,0) axis</entry>
            </row>
            <row>
              <entry>RotY (+,-)</entry>
              <entry>Add the given angle (in degree) to the rotation in the (0,1,0) axis</entry>
            </row>
            <row>
              <entry>RotZ (+,-)</entry>
              <entry>Add the given angle (in degree) to the rotation in the (0,0,1) axis</entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The corresponding entry <emphasis branch="">factor</emphasis> defines the corresponding amount of moving (<emphasis branch="">factor1</emphasis>) or zooming (<emphasis branch="">factor2</emphasis>). High values corresponds to small moving steps, tiny values to big steps.  </para>
      <para>After pressing one of the navigation button, the small preview control is updated automatically.</para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/Preview1.png" />
      </imageobject>
      <para>Here you see the rendered object in front view (the same view as the final rendering) and as symbolic black and white reversed top view. The top view helps to find the best viewing distance. If there are much black points at the top, the camera is to close, if there is only white space in the upper part, the camera is to far away.</para>
      <section>
        <title>Zooming</title>
        <para>The render window allows a zooming. First, you have to press the button <emphasis branch="">Zoom</emphasis>. After this you can select the zooming area with the mouse. It is also possible to double click an interesting part, which defines the center of the zoomed view. </para>
        <para>If the selection is done, the small rendering control is activated with the new settings. If the result looks good, you can start a new rendering by pressing <emphasis branch="">Start</emphasis>.</para>
      </section>
    </chapter>
    <chapter id="formula">
      <title>Formula</title>
      <para>
The type of the formula is defined in <link linkend="parameter.formula">Formula.Static.Formula</link>. Values from 1 to 26 corresponds to some inbuild formulas, but the most flexible way to work with formulas is to use the source code, defined in the <emphasis branch="">formula</emphasis> tab. 


If <emphasis branch="">Formula.Static.Formula=</emphasis>-1 the source code is called in mandelbrot mode (<emphasis branch="">Formula.Static.Formula=</emphasis>-2 corresponds to the julia mode). </para>
      <para>
      </para>
      <para>The difference between this two modes is a calling convention. Either the first arguments are the start values or the start arguments are given in the arguments 3 to 6. </para>
      <para>The return value is either 0 (if the point to test is inside the 3d object), or &gt;1 if outside. Values &gt;1 are used to define the colours in the cut plane.</para>
      <para>Allowed languages are C# or VB.Net.</para>
      <section>
        <title>Mandelbrot Mode</title>
        <para>If the border is defined by (-2,-2,-2) to (2,2,2), <emphasis branch="">Formula.Static.Formula=</emphasis>-1 and the formula is:  </para>
        <programlisting>public override long InSet(double ar, double ai, double aj,  double br, double bi, double bj, double bk, long zkl, bool invers) {

if(br*br+bi*bi+bj*bj &lt; 1)
            return (0);

return 1;

}</programlisting>
        <para>The result (after pressing <emphasis branch="">Preview</emphasis>) will looks like:</para>
        <imageobject>
          <title>
          </title>
          <imagedata format="png" fileref="pic/formula1.png" />
        </imageobject>
        <para>In Mandelbrot mode, the arguments are:</para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <emphasis>ar</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jx
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis>ai</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jy
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis>aj</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jz
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">br</emphasis>
                </entry>
                <entry>x-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">bi</emphasis>
                </entry>
                <entry>y-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">bj</emphasis>
                </entry>
                <entry>z-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">bk</emphasis>
                </entry>
                <entry>not used in mandelbrot mode</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">zkl</emphasis>
                </entry>
                <entry>The value of <emphasis>Formula.Static.Cycles</emphasis>, if there is an outside rendering or <emphasis>Formula.Static.MinCycle</emphasis> if the inside should be displayed. 
</entry>
              </row>
              <row>
                <entry>
                  <emphasis>invers</emphasis>
                </entry>
                <entry>This value is true, if inside rendering is <emphasis branch="">on</emphasis></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Julia Mode</title>
        <para>If the border is defined by (-2,-2,-2) to (2,2,2), <emphasis branch="">Formula.Static.Formula=</emphasis>-1 and the formula is:  </para>
        <programlisting>public override long InSet(double ar, double ai, double aj,  double br, double bi, double bj, double bk, long zkl, bool invers) {

if(br*br+bi*bi+bj*bj &lt; 1)
            return (0);

return 1;

}</programlisting>
        <para>The result is just a black bitmap. In julia mode, the arguments <emphasis branch="">br</emphasis>,<emphasis branch="">bi</emphasis> and <emphasis branch="">bj</emphasis> are fixed and the point to test is given by (<emphasis branch="">ar</emphasis>,<emphasis branch="">ai</emphasis>,<emphasis branch="">aj</emphasis>).</para>
        <para>All other parameters are defined similar to the mandelbrot mode. </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <emphasis branch="">ar</emphasis>
                </entry>
                <entry>x-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">ai</emphasis>
                </entry>
                <entry>y-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">aj</emphasis>
                </entry>
                <entry>z-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis>br</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jx
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis>bi</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jy
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis>bj</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jz
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis>bk</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jzz
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">zkl</emphasis>
                </entry>
                <entry>The value of <emphasis>Formula.Static.Cycles</emphasis>, if there is an outside rendering or <emphasis>Formula.Static.MinCycle</emphasis> if the inside should be displayed. 
</entry>
              </row>
              <row>
                <entry>
                  <emphasis>invers</emphasis>
                </entry>
                <entry>This value is true, if inside rendering is <emphasis branch="">on</emphasis></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>Predefined Mathematical methods has to start with <emphasis branch="">Math</emphasis>.</para>
        <programlisting>public override long InSet(double ar, double ai, double aj,  double br, double bi, double bj, double bk, long zkl, bool invers) {

if(ar*ar+ai*ai+aj*aj1)
            return (0);

if(Math.Abs(ar)+Math.Abs(ai)+Math.Abs(aj)&lt;1.4)
            return (0);

return 1;
}</programlisting>
        <imageobject>
          <title>
          </title>
          <imagedata format="jpg" fileref="pic/formula2.jpg" />
        </imageobject>
      </section>
      <section>
        <title>Surface Color</title>
        <para>Surface colours can be defined in the field <emphasis branch="">additionalPointInfo</emphasis>. The rgb-values of the surface color corresponds to (<emphasis branch="">additionalPointInfo.red</emphasis>, <emphasis branch="">additionalPointInfo.green</emphasis>, <emphasis branch="">additionalPointInfo.blue</emphasis>). </para>
        <para>To use this property, <emphasis branch="">additionalPointInfo</emphasis> has to be created in the Init() method.</para>
        <programlisting>public override void Init() {
  base.Init();
  additionalPointInfo=new AdditionalPointInfo();
}</programlisting>
        <para>Now <emphasis branch="">additionalPointInfo</emphasis> can be used in the method <emphasis branch="">InSet</emphasis>.</para>
        <programlisting>
public override long InSet(double ar, double ai, double aj,  double br, double bi, double bj, double bk, long zkl, bool invers) {

  additionalPointInfo.red=0;
  additionalPointInfo.green=0;
  additionalPointInfo.blue=0;

  if(ar*ar+ai*ai+aj*aj&lt;1) {
    additionalPointInfo.red=1;
    additionalPointInfo.green=1;
    return (0);
  }

  if(Math.Abs(ar)+Math.Abs(ai)+Math.Abs(aj)&lt;1.4) {
    additionalPointInfo.blue=0.6;
    return (0);
  }

  return 1;
}</programlisting>
        <imageobject>
          <title>
          </title>
          <imagedata format="jpg" fileref="pic/formula3.jpg" />
        </imageobject>
      </section>
      <section>
        <title>Inside Rendering</title>
        <para>It is (at least for the author of this documentation) one of the surprising results in the 3D fractal generation, that the complement of some 3D objects are looking different than the original object. The rendering of this complement is often denoted in this document as inside rendering.</para>
        <para>To switch on the inside rendering of the 3D object, move the camera forward until the virtual monitor screen is touched. On the touch plane, the inside rendering is activatet and the  <emphasis branch="">invers</emphasis> parameter is <emphasis branch="">true</emphasis>. The formula must now return 0 if the test point is outside, and a value &gt;0 if the testpoint is inside the 3D object.  </para>
        <programlisting>public override void Init() {
  base.Init();
  additionalPointInfo=new AdditionalPointInfo();
}

public override long InSet(double ar, double ai, double aj,  double br, double bi, double bj, double bk, long zkl, bool invers) {


additionalPointInfo.red=0;
additionalPointInfo.green=0;
additionalPointInfo.blue=0;

if(ar*ar+ai*ai+aj*aj &lt; 1) {
  additionalPointInfo.red=1;
  additionalPointInfo.green=1;
  if (invers) return 1;
  return (0);
}

if(Math.Abs(ar)+Math.Abs(ai)+Math.Abs(aj) &lt; 1.4) {
   additionalPointInfo.blue=0.6;
   if (invers) return 1;
   return (0);
}

  if (invers) return 0;
  return 1;
}</programlisting>
        <imageobject>
          <title>
          </title>
          <imagedata format="jpg" fileref="pic/formula4.jpg" />
        </imageobject>
      </section>
      <section>
        <title>Methods and Datatypes</title>
        <para>There are some predefined methods and datatypes, which will be documented here.</para>
        <section>
          <title>Access to Global Parameters</title>
          <para>
          </para>
          <para>You can set the value of all global parameters,</para>
          <programlisting>public void Set(string id, int value); 
public void Set(string id, double value);
public void Set(string id, bool value);
</programlisting>
          <para>read the value of all global parameters</para>
          <programlisting> public double GetDouble(string id);</programlisting>
          <para>or you can define new global parameters.</para>
          <programlisting> public void AddValue(string id, double value);
</programlisting>
          <para>A bulk of parameters at the same time can be set with the method <application branch="">SetParameterBulk(string xmlDescription)</application>. The XML description is the same, as the settings in the project file.</para>
          <programlisting>SetParameterBulk("<Entry Key="Border.Max.x" Value="1.5" /><Entry Key="Border.Max.y" Value="1.5" />");</programlisting>
        </section>
        <section>
          <title>Init</title>
          <para>The method Init() is called at the start of the rendering process. This function is a good place to perform some time consuming computations, which dos not need to called for each testing point. Furthermore, the reading of global parameters should be performed here, because the user is able to change some global parameters while the rendering process is running.</para>
          <programlisting>public override void Init() {
  base.Init();
  additionalPointInfo=new AdditionalPointInfo();
}</programlisting>
        </section>
        <section>
          <title>Vectorrotation</title>
          <para>The class <emphasis branch="">VecRotation</emphasis> can be used to define a rotation in 3d space. The properties (x,y,z) defines the rotation vector, while angle is the rotation angle. An angle with value Math.Pi defines a rotation of 180 degree. Use the method getTransform(Fractrace.Geometry.Vec3 pos) to apply this transformation to pos (as result value).</para>
          <programlisting>Fractrace.Geometry.VecRotation vecRot = new Fractrace.Geometry.VecRotation();
vecRot.x = 0;
vecRot.y = 0;
vecRot.z = 1;
vecRot.angle = phi;
Fractrace.Geometry.Vec3 newPos= vecRot.getTransform(pos);
x = newPos.X;
y = newPos.Y;
z = newPos.Z;



</programlisting>
        </section>
      </section>
      <section>
        <title>Bugs</title>
        <para>To compile the formula source with the C# or vb.net compiler, you have to activate the small rendering control (the left square in the bottom frame). Syntax errors are displayed in a subframe (here a german error message) and the line with the first error is displayed red.
</para>
        <para />
        <imageobject>
          <title>
          </title>
          <imagedata format="png" fileref="pic/error.png" />
        </imageobject>
        <para>Pressing the small button on the left closes the error frame.</para>
      </section>
    </chapter>
    <chapter id="animation">
      <title>Animation</title>
      <para>
      </para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/AnimationControl1.png" />
      </imageobject>
      <para>Pressing the Button, marked with +, adds the last rendered scene (either via <emphasis branch="">Preview</emphasis> or <emphasis branch="">Start</emphasis> to the animation key frame list. </para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/AnimationControl2.png" />
      </imageobject>
      <para>An animation frame entry starts with <application branch="">Run</application>. The parameter <application branch="">Steps</application> defines the number of frames in this animation step.</para>
      <para>The entry <emphasis branch="">Size</emphasis> corresponds to the parameter <emphasis branch="">View.Size</emphasis>. This value is set in each frame of the animation. </para>
      <para>The generation of all frames begins after pressing the button <emphasis branch="">Start</emphasis></para>
      <para>Pressing <emphasis branch="">Stop</emphasis> in the animation tab aborts the animation process, but does not stop the generation of the current frame. To stop this, you have to additionally press <emphasis branch="">Stop</emphasis> in the render frame.</para>
    </chapter>
    <chapter>
      <title>History</title>
      <para>All used parameter setting in the current session are automatically saved in the history tab. </para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/history.png" />
      </imageobject>
      <para>You can use a button with a displayed number to navigate directly to the corresponding parameter set. Use the button, marked with &lt;- or -&gt; to skip all parameter sets, where no preview bitmap is available.</para>
      <para>In most cases (i.e. if you use a navigation button or press the small render control) the current parameter setting is added in the history line. If you don't want to activate the render control, you can save the current settings by pressing <emphasis branch="">Save</emphasis>.</para>
    </chapter>
  </part>
  <part>
    <title>References</title>
    <para>
    </para>
    <chapter>
      <title>Parameter</title>
      <para>
      </para>
      <section>
        <title>Animation</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Animation.Steps</entry>
                <entry> Default animation steps while adding the frame in the animation control. 
</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="parameter.border">
        <title>Border</title>
        <para>The border defines the bounding box of the computed point set. If you set this borde by hand, make sure, that you press <emphasis branch="">Automatic</emphasis> in the tab <emphasis branch="">Navigate</emphasis> to fix this values corresponding to the choosen window size.</para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Border.Max.x</entry>
                <entry>Maximal X-Value</entry>
              </row>
              <row>
                <entry>Border.Max.y</entry>
                <entry>Maximal Y-Value</entry>
              </row>
              <row>
                <entry>Border.Max.z</entry>
                <entry>Maximal Z-Value</entry>
              </row>
              <row>
                <entry>Border.Min.x</entry>
                <entry>Minimal X-Value</entry>
              </row>
              <row>
                <entry>Border.Min.y</entry>
                <entry>Minimal Y-Value</entry>
              </row>
              <row>
                <entry>Border.Min.z</entry>
                <entry>Minimal Z-Value</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Computation</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Computation.NoOfThreads</entry>
                <entry>Number of threads used in computation. The recommended value is the number of processors.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="parameter.formula">
        <title>Formula</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Formula.Static.jx</entry>
                <entry>
                  <para>
X-component of the Julia Seed, if the formula is in julia mode.</para>
                  <para>
X-component of the start value , if the formula is in mandelbrot mode.
</para>
                </entry>
              </row>
              <row>
                <entry>Formula.Static.jy</entry>
                <entry>
                  <para>
Y-component of the Julia Seed, if the formula is in julia mode.</para>
                  <para>
Y-component of the start value , if the formula is in mandelbrot mode.
</para>
                </entry>
              </row>
              <row>
                <entry>Formula.Static.jz</entry>
                <entry>
                  <para>
Z-component of the Julia Seed, if the formula is in julia mode.</para>
                  <para>
Z-component of the start value , if the formula is in mandelbrot mode.
</para>
                </entry>
              </row>
              <row>
                <entry>Formula.Static.jzz</entry>
                <entry>Q-component of the Julia Seed, if the formula is in julia mode.</entry>
              </row>
              <row>
                <entry>Formula.Static.Cycles</entry>
                <entry>Number of iterations used in the formula.</entry>
              </row>
              <row>
                <entry>Formula.Static.MinCycle</entry>
                <entry>
                  <para>Number of iterations used in the formula, if the inside of the 3D object is rendered.</para>
                  <para>
If minCycle=51, then inside rendering is deactivated.</para>
                </entry>
              </row>
              <row>
                <entry>Formula.Static.Formula</entry>
                <entry>
                  <para>The used formula. Values from 1 to 26 corresponds to some inbuild formulas.</para>
                  <para>Formula.Static.Formula=-1: Use "Intern.Formula.Source" in mandelbrot mode.</para>
                  <para>Formula.Static.Formula=-2: Use "Intern.Formula.Source" in julia mode.</para>
                </entry>
              </row>
              <row>
                <entry>Intern.Formula.Source</entry>
                <entry>Source code of the formula, if Formula.Static.Formula &lt; 0.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="composite">
        <title>Renderer</title>
        <para>
        </para>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>AmbientIntensity</entry>
                <entry>Strength of blurring. Use 0 for a sharp picture. A value of 5 gives a smart background blurring  </entry>
              </row>
              <row>
                <entry>ColorGreyness</entry>
                <entry>use 0 for default color settings and 1 for a grey surface coloring (or a double value between 0 and 1)</entry>
              </row>
              <row>
                <entry>ColorIntensity</entry>
                <entry>Intensty of the color, use 0 for no color, 1 for default coloring or a value&gt;1 for very colorful result</entry>
              </row>
              <row>
                <entry>LightIntensity</entry>
                <entry>Set the amount of phong shading, compared with shadow rendering. Use 0 for shadow rendering only or 1 for phong shading only (or a value between 0 and 1 for a combination of both)</entry>
              </row>
              <row>
                <entry>MaxFieldOfView</entry>
                <entry>Upper bound for the field of view. If this parameter is 1, the objects near the camera are sharp.</entry>
              </row>
              <row>
                <entry>MinFieldOfView</entry>
                <entry>Lower bound for the field of view.</entry>
              </row>
              <row>
                <entry>Normalise</entry>
                <entry>(0/1 value) Normalise the color and light parameter to get the best picture results. In animations this parameter should be set to 0. 
</entry>
              </row>
              <row>
                <entry>ShadowJustify</entry>
                <entry>The default shadow light angle. Use high values for illuminating deep holes</entry>
              </row>
              <row>
                <entry>ShadowNumber</entry>
                <entry>The number of used shadows. Higher values gives a better picture quality, but needs more time </entry>
              </row>
              <row>
                <entry>Shininess</entry>
                <entry>shininess in phong shading.  </entry>
              </row>
              <row>
                <entry>ShininessFactor</entry>
                <entry>Influence of the shininess. Allowed values are between 0 and 1</entry>
              </row>
              <row>
                <entry>UseDarken</entry>
                <entry>Set this value to 1, if the background of the picture should be smoothed to black</entry>
              </row>
              <row>
                <entry>UseLight</entry>
                <entry>Enable phong shading</entry>
              </row>
              <row>
                <entry>UseSharpShadow</entry>
                <entry>A value of 1 adds a sharp shadow to the phong shading. Be careful with this parameter. The sharp shadow needs a lot of computing time.</entry>
              </row>
              <row>
                <entry>ColorFactor.Blue</entry>
                <entry>Color factor for the blue rgb component</entry>
              </row>
              <row>
                <entry>ColorFactor.Green</entry>
                <entry>Color factor for the green rgb component</entry>
              </row>
              <row>
                <entry>ColorFactor.Red</entry>
                <entry>Color factor for the red rgb component</entry>
              </row>
              <row>
                <entry>ColorFactor.RgbType</entry>
                <entry>Possible values are 1,...,6. Here you can vary the used rgb components. Choose 1, if you want to use the original values, defined in the formula.</entry>
              </row>
              <row>
                <entry>Light</entry>
                <entry>The x,y,z component of the light vector which is used in phong shading</entry>
              </row>
            </tbody>
          </tgroup>
</table>
      </section>
      <section id="parameter.transformation">
        <title>Transformation</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Transformation.Stereo.EyeDistance</entry>
                <entry>EyeDistance in stereo mode.</entry>
              </row>
              <row>
                <entry>Transformation.Stereo.Angle</entry>
                <entry>Angle difference in stereo mode. </entry>
              </row>
              <row>
                <entry>Transformation.Camera.AngleX</entry>
                <entry>Rotation angle (in degree) for axis x (rotation center is center of the given bounds).</entry>
              </row>
              <row>
                <entry>Transformation.Camera.AngleY</entry>
                <entry>Rotation angle (in degree) for axis y (rotation center is center of the given bounds).</entry>
              </row>
              <row>
                <entry>Transformation.Camera.AngleZ</entry>
                <entry>Rotation angle (in degree) for axis z (rotation center is center of the given bounds)</entry>
              </row>
              <row>
                <entry>Transformation.Perspective.Cameraposition</entry>
                <entry>Distance to the virtual screen. Small values gives a more 3D effect. Large values
      // gives the scene a parallel projection view.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>View</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>View.Raster</entry>
                <entry>
                  <para>Rendering Quality.</para>
                  <para>View.Raster=1: best quality</para>
                  <para>View.Raster=2, up to 8 times faster than View.Raster=1, but less nice - especially at the object borders.</para>
                </entry>
              </row>
              <row>
                <entry>View.Size</entry>
                <entry>
                  <para>width of the rendered bitmap=View.Size*View.Width</para>
                  <para>height of the rendered bitmap=View.Size*View.Height</para>
                </entry>
              </row>
              <row>
                <entry>View.Perspective</entry>
                <entry>Switch between 3D view and parallel view.</entry>
              </row>
              <row>
                <entry>View.Width</entry>
                <entry>View.Size*View.Width == width of the rendered bitmap.</entry>
              </row>
              <row>
                <entry>View.Height</entry>
                <entry>View.Size*View.Height == height of the rendered bitmap.</entry>
              </row>
              <row>
                <entry>View.Deph</entry>
                <entry>Virtual voxel space at the y-coordinate. Higher values :-&gt; more accurate rendering, but 
      // more time consuming.</entry>
              </row>
              <row>
                <entry>View.DephAdd</entry>
                <entry>Additional voxel space (removes black background parts of the rendered image).</entry>
              </row>
              <row>
                <entry>View.PosterZ</entry>
                <entry>
                  <para>Used internaly in creating of a poster.</para>
                  <para>PosterZ=-1: Render the bitmap above the given bounds.</para>
                  <para>PosterZ=1: Render the bitmap below the given bounds.</para>
                </entry>
              </row>
              <row>
                <entry>View.PosterX</entry>
                <entry>
                  <para>Used internally in creating a poster.</para>
                  <para>PosterX=-1: Render the bitmap left the given bounds.</para>
                  <para>PosterX=1: Render the bitmap right the given bounds.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </chapter>
  </part>
  <part>
    <title>Appendix</title>
    <para>
    </para>
    <chapter>
      <title>Dictionary</title>
      <para>
      </para>
      <section id="tomographicfunction">
        <title>Tomographic Function</title>
        <para>  A tomographic function <emphasis branch="">T(p)</emphasis> (<emphasis branch="">p</emphasis> is a point <emphasis branch="">p=(x,y,z)</emphasis> in <emphasis branch="">R^3</emphasis>) returns either <emphasis branch="">true</emphasis> or <emphasis branch="">false</emphasis>. The rendering
      interpreted this as formula description of an arbitrary object in the 3D space. This means: <emphasis branch="">T(p)=true</emphasis>,
      if and only if <emphasis branch="">p</emphasis> is inside the object.</para>
      </section>
    </chapter>
  </part>
</book>
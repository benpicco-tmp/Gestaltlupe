<?xml version="1.0" encoding="utf-8"?>
<book id="book" lang="de">
  <bookinfo>
    <title>Book</title>
  </bookinfo>
  <!--
  <part>
    <title>Introduction</title>
    
    <para>
Gestaltlupe is a scientific tool to render tomographic functions. 
A tomographic function <emphasis branch="">T(p)</emphasis> (<emphasis branch="">p</emphasis> is a point <emphasis branch="">p=(x,y,z)</emphasis> in <emphasis branch="">R^3</emphasis>) returns either <emphasis branch="">true</emphasis> or <emphasis branch="">false</emphasis>. The rendering 
interpreted this as formula description of an arbitrary object in the 3D space. This means: <emphasis branch="">T(p)=true</emphasis>, 
if and only if <emphasis branch="">p</emphasis> is inside the object. </para>
    <para>
Double click on <application branch="">Gestaltlupe_1_0_2.exe</application> , choose Tab <emphasis branch="">file</emphasis>, load an sample project and press the 
button “preview” to get after a short time a small picture of the given 3D object, or press "start" 
to render a bitmap in full resolution. </para>
  </part>
  <part>
    <title>Install</title>



<para>Gestaltlupe is available at GitHub at:

<ulink url="" branch="">http://github.com/trafassel/Gestaltlupe </ulink>
   
The corresponding Version 1.0.2, which is documented here, can be found at:

<ulink url="" branch="">http://github.com/trafassel/Gestaltlupe/blob/master/bin/Gestaltlupe_1_0_2.exe </ulink>

On this page you have to click “raw” to get the binary.  But the recommended way to work with 
Gestaltlupe is to download the full archive file (the big “Download” button at 
<ulink url="" branch="">http://github.com/trafassel/Gestaltlupe </ulink>). The archive contains the binaries and sample projects 
with the corresponding formulas.
</para>
    <para />
    <chapter>
      <title>Windows</title>
      <para>
Gestaltlupe is developed and tested with WindowsXP and Windows7. It is a native .NET 2.0 application. </para>
    </chapter>
    <chapter>
      <title>Linux</title>
      <para>To run Gestaltlupe  on a Linux system, you have to install the mono package 
(<ulink url="" branch="">http://www.mono-project.com/Main_Page </ulink>). It is tested on a Ubuntu Hardy Heron 8.04.3 LTS. 
It runs without problems, but looks more ugly than the windows version (Yes, that is possible).</para>
    </chapter>
    <chapter>
      <title>Mac OSX</title>
      <para>
It is tested on a Mac OSX 10.6. with Mono 2.8 . It can produce some nice pictures, but working is a 
pain, because some windows forms are not redrawn properly (Gestaltlupe is compatible to the 
Windows.Forms library 2.0).</para>
    </chapter>
  </part>
  -->
  <part>
    <title>Introduction</title>
    <para>
      Gestaltlupe is a scientific tool to render tomographic functions.
      A tomographic function <emphasis branch="">T(p)</emphasis> (<emphasis branch="">p</emphasis> is a point <emphasis branch="">p=(x,y,z)</emphasis> in <emphasis branch="">R^3</emphasis>) returns either <emphasis branch="">true</emphasis> or <emphasis branch="">false</emphasis>. The rendering
      interpreted this as formula description of an arbitrary object in the 3D space. This means: <emphasis branch="">T(p)=true</emphasis>,
      if and only if <emphasis branch="">p</emphasis> is inside the object.
    </para>
    <para>
      Double click on <application branch="">Gestaltlupe_1_0_2.exe</application> , choose Tab <emphasis branch="">file</emphasis>, load an sample project and press the
      button “preview” to get after a short time a small picture of the given 3D object, or press "start"
      to render a bitmap in full resolution.
    </para>
  </part>
  <part>
    <title>Install</title>
    <para>
      Gestaltlupe is available at GitHub at:

      <ulink url="http://github.com/trafassel/Gestaltlupe">http://github.com/trafassel/Gestaltlupe </ulink>

      The corresponding Version 1.0.2, which is documented here, can be found at:

      <ulink url="http://github.com/trafassel/Gestaltlupe/blob/master/bin/Gestaltlupe_1_0_2.exe">http://github.com/trafassel/Gestaltlupe/blob/master/bin/Gestaltlupe_1_0_2.exe </ulink>

      On this page you have to click “raw” to get the binary.  But the recommended way to work with
      Gestaltlupe is to download the full archive file (the big “Download” button at
      <ulink url="http://github.com/trafassel/Gestaltlupe" branch="">http://github.com/trafassel/Gestaltlupe </ulink>). The archive contains the binaries and sample projects
      with the corresponding formulas.
    </para>
    <para />
    <chapter>
      <title>Windows</title>
      <para>
        Gestaltlupe is developed and tested with WindowsXP and Windows7. It is a native .NET 2.0 application.
      </para>
    </chapter>
    <chapter>
      <title>Linux</title>
      <para>
        To run Gestaltlupe  on a Linux system, you have to install the mono package
        (<ulink url="" branch="">http://www.mono-project.com/Main_Page </ulink>). It is tested on a Ubuntu Hardy Heron 8.04.3 LTS.
        It runs without problems, but looks more ugly than the windows version (Yes, that is possible).
      </para>
    </chapter>
    <chapter>
      <title>Mac OSX</title>
      <para>
        It is tested on a Mac OSX 10.6. with Mono 2.8 . It can produce some nice pictures, but working is a
        pain, because some windows forms are not redrawn properly (Gestaltlupe is compatible to the
        Windows.Forms library 2.0).
      </para>
    </chapter>
  </part>
  <part>
    <title>Interface Description</title>
    <para>After its first start, Gestaltlupe presents the parameter input formular.</para>
    <imageobject>
      <title>Start Screen</title>
      <imagedata format="png" fileref="pic/start.png" />
    </imageobject>
    <para>If you click on the left square in the bottom frame, you get a small overview of the defined scene. </para>
    <imageobject>
      <title>
      </title>
      <imagedata format="png" fileref="pic/firstPic.png" />
    </imageobject>
    <para>If the view looks OK, you can click on <emphasis branch="">Preview</emphasis> to get a greater picture. The result ist presented in the output window.</para>
    <imageobject>
      <title>
      </title>
      <imagedata format="png" fileref="pic/FirstPreview.png" />
    </imageobject>
    <para>The picture is saved automatic. The corresponding path is given at the top of the output window.</para>
    <para>The final rendering starts after click on the button <emphasis branch="">Start</emphasis>.</para>
    <imageobject>
      <title>
      </title>
      <imagedata format="png" fileref="pic/firstRendering.png" />
    </imageobject>
    <para>Are you satisfied with the result? Not, oh, ...</para>
    <para>If you want to improve the quality of the rendering result, you have to read the chapter <link linkend="rendering" branch="">Rendering</link>. </para>
    <para>Or you want to see, what is inside the tunnel or rotate and zoom the whole object.
The chapter <link linkend="navigation">Navigation</link> describes, how to navigate in the virtual 3D space.</para>
    <para>I understand. You favourite formula is another fractal, and you want some colours. Then you have to read the chapter <link linkend="formula">Formula</link>.  </para>
    <para>If you are completed your study in navigation or formula description, you are ready for your first <link linkend="animation">animation</link>. </para>
    <chapter id="rendering">
      <title>Rendering</title>
      <para>Rendering is a 2 stage process. 

In the first stage the geometry is generated. The geometry data for each pixel of the resulting bitmap contains:

<itemizedlist branch=""><listitem>the exact coordinates of the corresponding surface point</listitem><listitem>the normal of the surface at this point</listitem><listitem>and (eventually) the surface color</listitem></itemizedlist></para>
      <para>
In the second stage the renderer generates the bitmap from the geometry data . Because the renderer got only informations of the visible points, the ability to generate a cinema like raytracing picture is limited. </para>
      <para>
The first stage used multiple threads. This means, the computation is done on multiple processors. 
The second stage runs in one thread, uses only one processor and blocks the whole application.</para>
      <para>There are 6 different renderers. To choose another one, you have to set <link linkend="composite">Composite.Renderer</link> to the name (or number) of your favourite renderer type, and press <emphasis branch="">Repaint</emphasis> in the result window. This is much faster than pressing <emphasis branch="">Start</emphasis> in the parameter window. Using of <emphasis branch="">Repaint</emphasis> is also recommended, if you change some of the rendering <link linkend="composite" branch="">parameters</link>.</para>
      <section>
        <title>FastScienceRenderer</title>
        <para>
        </para>
        <imageobject>
          <title>
          </title>
          <imagedata format="png" fileref="pic/FastScienceRenderer.png" />
        </imageobject>
      </section>
      <section>
        <title>ScienceRenderer</title>
        <para>
        </para>
        <imageobject>
          <title>
          </title>
          <imagedata format="png" fileref="pic/ScienceRenderer.png" />
        </imageobject>
      </section>
      <section>
        <title>NiceRenderer</title>
        <para>
        </para>
        <imageobject>
          <title>
          </title>
          <imagedata format="png" fileref="pic/NiceRenderer.png" />
        </imageobject>
      </section>
      <section>
        <title>BroadcastRenderer</title>
        <para>
        </para>
        <imageobject>
          <title>
          </title>
          <imagedata format="png" fileref="pic/BroadcastRenderer.png" />
        </imageobject>
      </section>
      <section>
        <title>SharpRenderer</title>
        <para>
        </para>
        <imageobject>
          <title>
          </title>
          <imagedata format="png" fileref="pic/SharpRenderer.png" />
        </imageobject>
      </section>
      <section>
        <title>UniversalRenderer</title>
        <para>
        </para>
        <imageobject>
          <title>
          </title>
          <imagedata format="png" fileref="pic/UniversalRenderer.png" />
        </imageobject>
      </section>
      <section>
        <title>PlasicRenderer</title>
        <para>
        </para>
        <imageobject>
          <title>
          </title>
          <imagedata format="png" fileref="pic/PlasicRenderer.png" />
        </imageobject>
      </section>
    </chapter>
    <chapter id="navigation">
      <title>Navigation</title>
      <para>The area in 3D space, which will be used for the rendering of the 3D object is defined in the <link linkend="parameter.border">border</link> parameters. The monitor plane corresponds to  <emphasis branch="">(x,z)</emphasis> and the direction of the y-axis is the depth.   </para>
      <para>The camera settings (i.e. rotations) are given in <link linkend="parameter.transformation">Transformation</link>. Some of this parameters can be manipulated in the navigation control.</para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/Navigate.png" />
      </imageobject>
      <para>If you press one of the buttons, the small preview control at the bottom is redrawn automatically, but you don't have to wait for completing the picture.  I.e. defining a factor value of 12 and double pressing of <emphasis branch="">left</emphasis> (&lt;-) is the same as factor=6 and pressing <emphasis branch="">left</emphasis> just one time.</para>
      <table>
        <title>
        </title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>Symbol</entry>
              <entry>Description</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>&gt; &lt;</entry>
              <entry>move forward</entry>
            </row>
            <row>
              <entry>&lt;&gt;</entry>
              <entry>move back</entry>
            </row>
            <row>
              <entry>/\</entry>
              <entry>move up</entry>
            </row>
            <row>
              <entry>\/</entry>
              <entry>move down</entry>
            </row>
            <row>
              <entry>&lt;-</entry>
              <entry>move left</entry>
            </row>
            <row>
              <entry>-&gt;</entry>
              <entry>move right</entry>
            </row>
            <row>
              <entry>+</entry>
              <entry>zoom in</entry>
            </row>
            <row>
              <entry>-</entry>
              <entry>zoom out</entry>
            </row>
            <row>
              <entry>RotX (+,-)</entry>
              <entry>Add the given angle (in degree) to the rotation in the (1,0,0) axis</entry>
            </row>
            <row>
              <entry>RotY (+,-)</entry>
              <entry>Add the given angle (in degree) to the rotation in the (0,1,0) axis</entry>
            </row>
            <row>
              <entry>RotZ (+,-)</entry>
              <entry>Add the given angle (in degree) to the rotation in the (0,0,1) axis</entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
            <row>
              <entry>
              </entry>
              <entry>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The corresponding entry <emphasis branch="">factor</emphasis> defines the corresponding amount of moving (<emphasis branch="">factor1</emphasis>) or zooming (<emphasis branch="">factor2</emphasis>). High values corresponds to small moving steps, tiny values to big steps.  </para>
    </chapter>
    <chapter id="formula">
      <title>Formula</title>
      <para>
The type of the formula is defined in <link linkend="parameter.formula">Formula.Static.Formula</link>. Values from 1 to 26 corresponds to some inbuild formulas, but the most flexible way to work with formulas is to use the source code, defined in the <emphasis branch="">formula</emphasis> tab. 


If <emphasis branch="">Formula.Static.Formula=</emphasis>-1 the source code is called in mandelbrot mode (<emphasis branch="">Formula.Static.Formula=</emphasis>-2 corresponds to the julia mode). </para>
      <para>
      </para>
      <para>The difference between this two modes is a calling convention. Either the first arguments are the start values or the start arguments are given in the arguments 3 to 6. </para>
      <para>The return value is either 0 (if the point to test is inside the 3d object), or &gt;1 if outside. Values &gt;1 are used to define the colours in the cut plane.</para>
      <section>
        <title>Mandelbrot Mode</title>
        <para>If the border is defined by (-2,-2,-2) to (2,2,2), <emphasis branch="">Formula.Static.Formula=</emphasis>-1 and the formula is:  </para>
        <programlisting>public override long InSet(double ar, double ai, double aj,  double br, double bi, double bj, double bk, long zkl, bool invers) {

if(br*br+bi*bi+bj*bj &lt; 1)
            return (0);

return 1;

}</programlisting>
        <para>The result (after pressing <emphasis branch="">Preview</emphasis>) will looks like:</para>
        <imageobject>
          <title>
          </title>
          <imagedata format="png" fileref="pic/formula1.png" />
        </imageobject>
        <para>In Mandelbrot mode, the arguments are:</para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <emphasis>ar</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jx
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis>ai</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jy
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis>aj</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jz
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">br</emphasis>
                </entry>
                <entry>x-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">bi</emphasis>
                </entry>
                <entry>y-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">bj</emphasis>
                </entry>
                <entry>z-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">bk</emphasis>
                </entry>
                <entry>not used in mandelbrot mode</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">zkl</emphasis>
                </entry>
                <entry>The value of <emphasis>Formula.Static.Cycles</emphasis>, if there is an outside rendering or <emphasis>Formula.Static.MinCycle</emphasis> if the inside should be displayed. 
</entry>
              </row>
              <row>
                <entry>
                  <emphasis>invers</emphasis>
                </entry>
                <entry>This value is true, if inside rendering is <emphasis branch="">on</emphasis></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>Julia Mode</title>
        <para>If the border is defined by (-2,-2,-2) to (2,2,2), <emphasis branch="">Formula.Static.Formula=</emphasis>-1 and the formula is:  </para>
        <programlisting>public override long InSet(double ar, double ai, double aj,  double br, double bi, double bj, double bk, long zkl, bool invers) {

if(br*br+bi*bi+bj*bj &lt; 1)
            return (0);

return 1;

}</programlisting>
        <para>The result is just a black bitmap. In julia mode, the arguments <emphasis branch="">br</emphasis>,<emphasis branch="">bi</emphasis> and <emphasis branch="">bj</emphasis> are fixed and the point to test is given by (<emphasis branch="">ar</emphasis>,<emphasis branch="">ai</emphasis>,<emphasis branch="">aj</emphasis>).</para>
        <para>All other parameters are defined similar to the mandelbrot mode. </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <emphasis branch="">ar</emphasis>
                </entry>
                <entry>x-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">ai</emphasis>
                </entry>
                <entry>y-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">aj</emphasis>
                </entry>
                <entry>z-component of the point to test</entry>
              </row>
              <row>
                <entry>
                  <emphasis>br</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jx
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis>bi</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jy
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis>bj</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jz
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis>bk</emphasis>
                </entry>
                <entry>The value of <emphasis branch="">Formula.Static.jzz
</emphasis></entry>
              </row>
              <row>
                <entry>
                  <emphasis branch="">zkl</emphasis>
                </entry>
                <entry>The value of <emphasis>Formula.Static.Cycles</emphasis>, if there is an outside rendering or <emphasis>Formula.Static.MinCycle</emphasis> if the inside should be displayed. 
</entry>
              </row>
              <row>
                <entry>
                  <emphasis>invers</emphasis>
                </entry>
                <entry>This value is true, if inside rendering is <emphasis branch="">on</emphasis></entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>Predefined Mathematical methods has to start with <emphasis branch="">Math</emphasis>.</para>
        <programlisting>public override long InSet(double ar, double ai, double aj,  double br, double bi, double bj, double bk, long zkl, bool invers) {

if(ar*ar+ai*ai+aj*aj1)
            return (0);

if(Math.Abs(ar)+Math.Abs(ai)+Math.Abs(aj)&lt;1.4)
            return (0);

return 1;
}</programlisting>
        <imageobject>
          <title>
          </title>
          <imagedata format="jpg" fileref="pic/formula2.jpg" />
        </imageobject>
      </section>
      <section>
        <title>Surface Color</title>
        <para>Surface colours can be defined in the field <emphasis branch="">additionalPointInfo</emphasis>. The rgb-values of the surface color corresponds to (<emphasis branch="">additionalPointInfo.red</emphasis>, <emphasis branch="">additionalPointInfo.green</emphasis>, <emphasis branch="">additionalPointInfo.blue</emphasis>). </para>
        <para>To use this property, <emphasis branch="">additionalPointInfo</emphasis> has to be created in the Init() method.</para>
        <programlisting>public override void Init() {
  base.Init();
  additionalPointInfo=new AdditionalPointInfo();
}</programlisting>
        <para>Now <emphasis branch="">additionalPointInfo</emphasis> can be used in the method <emphasis branch="">InSet</emphasis>.</para>
        <programlisting>
public override long InSet(double ar, double ai, double aj,  double br, double bi, double bj, double bk, long zkl, bool invers) {

  additionalPointInfo.red=0;
  additionalPointInfo.green=0;
  additionalPointInfo.blue=0;

  if(ar*ar+ai*ai+aj*aj&lt;1) {
    additionalPointInfo.red=1;
    additionalPointInfo.green=1;
    return (0);
  }

  if(Math.Abs(ar)+Math.Abs(ai)+Math.Abs(aj)&lt;1.4) {
    additionalPointInfo.blue=0.6;
    return (0);
  }

  return 1;
}</programlisting>
        <imageobject>
          <title>
          </title>
          <imagedata format="jpg" fileref="pic/formula3.jpg" />
        </imageobject>
      </section>
      <section>
        <title>Inside Rendering</title>
        <para>It is (at least for the author of this documentation) one of the surprising results in the 3D fractal generation, that the complement of some 3D objects are looking different than the original object. The rendering of this complement is often denoted in this document as inside rendering.</para>
        <para>To switch on the inside rendering of the 3D object, move the camera forward until the virtual monitor screen is touched. On the touch plane, the inside rendering is activatet and the  <emphasis branch="">invers</emphasis> parameter is <emphasis branch="">true</emphasis>. The formula must now return 0 if the test point is outside, and a value &gt;0 if the testpoint is inside the 3D object.  </para>
        <programlisting>public override void Init() {
  base.Init();
  additionalPointInfo=new AdditionalPointInfo();
}

public override long InSet(double ar, double ai, double aj,  double br, double bi, double bj, double bk, long zkl, bool invers) {


additionalPointInfo.red=0;
additionalPointInfo.green=0;
additionalPointInfo.blue=0;

if(ar*ar+ai*ai+aj*aj &lt; 1) {
  additionalPointInfo.red=1;
  additionalPointInfo.green=1;
  if (invers) return 1;
  return (0);
}

if(Math.Abs(ar)+Math.Abs(ai)+Math.Abs(aj) &lt; 1.4) {
   additionalPointInfo.blue=0.6;
   if (invers) return 1;
   return (0);
}

  if (invers) return 0;
  return 1;
}</programlisting>
        <imageobject>
          <title>
          </title>
          <imagedata format="jpg" fileref="pic/formula4.jpg" />
        </imageobject>
      </section>
      <section>
        <title>Methods and Datatypes</title>
        <para>There are some predefined methods and datatypes, which will be documented here.</para>
        <section>
          <title>Access to Global Parameters</title>
          <para>
          </para>
          <para>You can set the valu of all global parameters,</para>
          <programlisting>public void Set(string id, int value); 
public void Set(string id, double value);
public void Set(string id, bool value);
</programlisting>
          <para>read the value of all global parameters</para>
          <programlisting> public double GetDouble(string id);</programlisting>
          <para>or you can define new global parameters.</para>
          <programlisting> public void AddValue(string id, double value);
</programlisting>
        </section>
        <section>
          <title>Init</title>
          <para>The method Init() is called at the start of the rendering process. This function is a good place to perform some time consuming computations, which dos not need to called for each testing point. Furthermore, the reading of global parameters should be performed here, because the user is able to change some global parameters while the rendering process is running.</para>
          <programlisting>public override void Init() {
  base.Init();
  additionalPointInfo=new AdditionalPointInfo();
}</programlisting>
        </section>
        <section>
          <title>Vectorrotation</title>
          <para>
          </para>
        </section>
      </section>
      <section>
        <title>Bugs</title>
        <para>To compile the formula source with the C# compiler, you have to activate the small rendering control (the left square in the bottom frame). Syntax errors are displayed in a subframe (here a german error message).
</para>
        <para />
        <imageobject>
          <title>
          </title>
          <imagedata format="png" fileref="pic/error.png" />
        </imageobject>
        <para>The line info in the error message is not correct (the position is OK). The exact line where the error occurs is line-8. Pressing the small button on the left closes the error frame.</para>
      </section>
    </chapter>
    <chapter id="animation">
      <title>Animation</title>
      <para>
      </para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/AnimationControl1.png" />
      </imageobject>
      <para>Pressing the Button, marked with +, adds the last rendered scene (either via <emphasis branch="">Preview</emphasis> or <emphasis branch="">Start</emphasis> to the animation key frame list. </para>
      <imageobject>
        <title>
        </title>
        <imagedata format="png" fileref="pic/AnimationControl2.png" />
      </imageobject>
      <para>An animation frame entry starts with <application branch="">Run</application>. The parameter <application branch="">Steps</application></para>
    </chapter>
    <chapter>
      <title>History</title>
      <para>
      </para>
    </chapter>
  </part>
  <part>
    <title>References</title>
    <para>
    </para>
    <chapter>
      <title>Parameter</title>
      <para>
      </para>
      <section>
        <title>Animation</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Animation.Steps</entry>
                <entry> Default animation steps while adding the frame in the animation control. 
</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="parameter.border">
        <title>Border</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Border.Max.x</entry>
                <entry>Maximal X-Value</entry>
              </row>
              <row>
                <entry>Border.Max.y</entry>
                <entry>Maximal Y-Value</entry>
              </row>
              <row>
                <entry>Border.Max.z</entry>
                <entry>Maximal Z-Value</entry>
              </row>
              <row>
                <entry>Border.Min.x</entry>
                <entry>Minimal X-Value</entry>
              </row>
              <row>
                <entry>Border.Min.y</entry>
                <entry>Minimal Y-Value</entry>
              </row>
              <row>
                <entry>Border.Min.z</entry>
                <entry>Minimal Z-Value</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="composite">
        <title>Composite</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Composite.Blurring</entry>
                <entry> Strength of blurring (0-1)  [used in Renderer 2-4]</entry>
              </row>
              <row>
                <entry>Composite.BlurringDeph</entry>
                <entry>not used anymore</entry>
              </row>
              <row>
                <entry>Composite.BackgoundDarken</entry>
                <entry>Activates the darkening of distand points    [used in Renderer 2,3,4,6]</entry>
              </row>
              <row>
                <entry>Composite.Shininess</entry>
                <entry>Light and material property  [used in Renderer 2 - 4]</entry>
              </row>
              <row>
                <entry>Composite.UseAmbient</entry>
                <entry>Activates the Blurring.  [used in Renderer ?]</entry>
              </row>
              <row>
                <entry>Composite.UseDarken</entry>
                <entry>Activates the darkening of distand points    [used in Renderer ?]</entry>
              </row>
              <row>
                <entry>Composite.UseMedian</entry>
                <entry>Use object median instead of the center of the bounds [used in Renderer 2,3] </entry>
              </row>
              <row>
                <entry>Composite.UseDerivation</entry>
                <entry> [used in Renderer ?</entry>
              </row>
              <row>
                <entry>Composite.UseColor1</entry>
                <entry>Activates the surface color [used in Renderer ?] </entry>
              </row>
              <row>
                <entry>Composite.Color1Factor</entry>
                <entry> [used in Renderer ?]</entry>
              </row>
              <row>
                <entry>Composite.Color1TestArea</entry>
                <entry>[used in Renderer ?]</entry>
              </row>
              <row>
                <entry>Composite.FrontLight</entry>
                <entry>Activates additional front light  [used in Renderer ?]</entry>
              </row>
              <row>
                <entry>Composite.AmbientLight</entry>
                <entry>Activates additional ambient light  [used in Renderer ?]</entry>
              </row>
              <row>
                <entry>Composite.Normalize</entry>
                <entry>Normalise the color and light parameter to get the best picture results. Don't use this parameter in animations [apply to Renderer 2 - 5]</entry>
              </row>
              <row>
                <entry>Composite.Renderer</entry>
                <entry>
                  <para>
                    <itemizedlist>
                      <listitem>Composite.Renderer=0 : use FastScienceRenderer</listitem>
                      <listitem>Composite.Renderer=1 : use ScienceRenderer</listitem>
                      <listitem>Composite.Renderer=2 : use NiceRenderer</listitem>
                      <listitem>Composite.Renderer=3 : use BroadcastRenderer</listitem>
                      <listitem>Composite.Renderer=4 : use SharpRenderer</listitem>
                      <listitem>Composite.Renderer=5 : use UniversalRenderer</listitem>
                      <listitem>Composite.Renderer=6 : use PlasicRenderer</listitem>
                    </itemizedlist>
                  </para>
                </entry>
              </row>
              <row>
                <entry>Composite.Renderer.Universal.UseAmbient</entry>
                <entry>Activates Blurring in UniversalRenderer</entry>
              </row>
              <row>
                <entry>Composite.Renderer.Universal.UseDarken</entry>
                <entry>Activates Background darkening in UniversalRenderer</entry>
              </row>
              <row>
                <entry>Composite.Renderer.Universal.UseColorFromFormula</entry>
                <entry> Activates surface color in UniversalRenderer</entry>
              </row>
              <row>
                <entry>Composite.Renderer.Universal.UseMedianColorFromFormula</entry>
                <entry>Activates median for surface color in UniversalRenderer</entry>
              </row>
              <row>
                <entry>Composite.Renderer.Universal.ComicStyle</entry>
                <entry> Activates comic style (additional black lines at the border) in UniversalRenderer</entry>
              </row>
              <row>
                <entry>Composite.Renderer.Universal.FrontLightIntensity</entry>
                <entry> Intensity (0-1) of the Front Light in UniversalRenderer</entry>
              </row>
              <row>
                <entry>Composite.Renderer.Universal.AmbientLightIntensity</entry>
                <entry> Intensity (0-1) of the Ambient Light in UniversalRenderer.</entry>
              </row>
              <row>
                <entry>Composite.Renderer.Universal.Brightening</entry>
                <entry>Additional Brightening (0-1) in UniversalRenderer</entry>
              </row>
              <row>
                <entry>Composite.Renderer.Universal.NormalizeColors</entry>
                <entry> Normalise the color and light parameter to get the best picture results.
Don't use this parameter in animations [apply to UniversalRenderer]</entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
              <row>
                <entry>
                </entry>
                <entry>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <para>
        </para>
      </section>
      <section>
        <title>Computation</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Computation.NoOfThreads</entry>
                <entry>Number of threads used in computation. The recommended value is the number of processors.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="parameter.formula">
        <title>Formula</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Formula.Static.jx</entry>
                <entry>
                  <para>
X-component of the Julia Seed, if the formula is in julia mode.</para>
                  <para>
X-component of the start value , if the formula is in mandelbrot mode.
</para>
                </entry>
              </row>
              <row>
                <entry>Formula.Static.jy</entry>
                <entry>
                  <para>
Y-component of the Julia Seed, if the formula is in julia mode.</para>
                  <para>
Y-component of the start value , if the formula is in mandelbrot mode.
</para>
                </entry>
              </row>
              <row>
                <entry>Formula.Static.jz</entry>
                <entry>
                  <para>
Z-component of the Julia Seed, if the formula is in julia mode.</para>
                  <para>
Z-component of the start value , if the formula is in mandelbrot mode.
</para>
                </entry>
              </row>
              <row>
                <entry>Formula.Static.jzz</entry>
                <entry>Q-component of the Julia Seed, if the formula is in julia mode.</entry>
              </row>
              <row>
                <entry>Formula.Static.Cycles</entry>
                <entry>Number of iterations used in the formula.</entry>
              </row>
              <row>
                <entry>Formula.Static.MinCycle</entry>
                <entry>
                  <para>Number of iterations used in the formula, if the inside of the 3D object is rendered.</para>
                  <para>
If minCycle=51, then inside rendering is deactivated.</para>
                </entry>
              </row>
              <row>
                <entry>Formula.Static.Formula</entry>
                <entry>
                  <para>The used formula. Values from 1 to 26 corresponds to some inbuild formulas.</para>
                  <para>Formula.Static.Formula=-1: Use "Intern.Formula.Source" in mandelbrot mode.</para>
                  <para>Formula.Static.Formula=-2: Use "Intern.Formula.Source" in julia mode.</para>
                </entry>
              </row>
              <row>
                <entry>Intern.Formula.Source</entry>
                <entry>Source code of the formula, if Formula.Static.Formula &lt; 0.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section id="parameter.transformation">
        <title>Transformation</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>Transformation.Stereo.EyeDistance</entry>
                <entry>EyeDistance in stereo mode.</entry>
              </row>
              <row>
                <entry>Transformation.Stereo.Angle</entry>
                <entry>Angle difference in stereo mode. </entry>
              </row>
              <row>
                <entry>Transformation.AngleX</entry>
                <entry>Rotation angle (in degree) for axis x (center=(0,0,0)).</entry>
              </row>
              <row>
                <entry>Transformation.AngleY</entry>
                <entry>Rotation angle (in degree) for axis y (center=(0,0,0)).</entry>
              </row>
              <row>
                <entry>Transformation.AngleZ</entry>
                <entry>Rotation angle (in degree) for axis z (center=(0,0,0)).</entry>
              </row>
              <row>
                <entry>Transformation.Camera.AngleX</entry>
                <entry>Rotation angle (in degree) for axis x (rotation center is center of the given bounds).</entry>
              </row>
              <row>
                <entry>Transformation.Camera.AngleY</entry>
                <entry>Rotation angle (in degree) for axis y (rotation center is center of the given bounds).</entry>
              </row>
              <row>
                <entry>Transformation.Camera.AngleZ</entry>
                <entry>Rotation angle (in degree) for axis z (rotation center is center of the given bounds)</entry>
              </row>
              <row>
                <entry>Transformation.3.AngleX</entry>
                <entry>Rotation angle (in degree) for axis x (center=(Transformation.3.CenterX,Transformation.3.CenterY,Transformation.3.CenterZ)).</entry>
              </row>
              <row>
                <entry>Transformation.3.AngleY</entry>
                <entry>Rotation angle (in degree) for axis y (center=(Transformation.3.CenterX,Transformation.3.CenterY,Transformation.3.CenterZ)).</entry>
              </row>
              <row>
                <entry>Transformation.3.AngleZ</entry>
                <entry>Rotation angle (in degree) for axis z (center=(Transformation.3.CenterX,Transformation.3.CenterY,Transformation.3.CenterZ)).</entry>
              </row>
              <row>
                <entry>Transformation.3.CenterX</entry>
                <entry>x- component of the center of rotation Transformation.3</entry>
              </row>
              <row>
                <entry>Transformation.3.CenterY</entry>
                <entry>y- component of the center of rotation Transformation.3</entry>
              </row>
              <row>
                <entry>Transformation.3.CenterZ</entry>
                <entry>z- component of the center of rotation Transformation.3</entry>
              </row>
              <row>
                <entry>Transformation.Perspective.Cameraposition</entry>
                <entry>Distance to the virtual screen. Small values gives a more 3D effect. Large values
      // gives the scene a parallel projection view.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
      <section>
        <title>View</title>
        <para>
        </para>
        <table>
          <title>
          </title>
          <tgroup cols="2">
            <thead>
              <row>
                <entry>Name</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>View.Zoom</entry>
                <entry>Not used anymore</entry>
              </row>
              <row>
                <entry>View.Raster</entry>
                <entry>
                  <para>Rendering Quality.</para>
                  <para>View.Raster=1: best quality</para>
                  <para>View.Raster=2, up to 8 times faster than View.Raster=1, but less nice - especially at the object borders.</para>
                </entry>
              </row>
              <row>
                <entry>View.Size</entry>
                <entry>
                  <para>width of the rendered bitmap=View.Size*View.Width</para>
                  <para>height of the rendered bitmap=View.Size*View.Height</para>
                </entry>
              </row>
              <row>
                <entry>View.ClassicView</entry>
                <entry>Set "View.ClassicView" to 1 to activate the classic view ... eventually </entry>
              </row>
              <row>
                <entry>View.Perspective</entry>
                <entry>Switch between 3D view and parallel view.</entry>
              </row>
              <row>
                <entry>View.Width</entry>
                <entry>View.Size*View.Width == width of the rendered bitmap.</entry>
              </row>
              <row>
                <entry>View.Height</entry>
                <entry>View.Size*View.Height == height of the rendered bitmap.</entry>
              </row>
              <row>
                <entry>View.Deph</entry>
                <entry>Virtual voxel space at the y-coordinate. Higher values :-&gt; more accurate rendering, but 
      // more time consuming.</entry>
              </row>
              <row>
                <entry>View.DephAdd</entry>
                <entry>Additional voxel space (removes black background parts of the rendered image).</entry>
              </row>
              <row>
                <entry>View.PosterZ</entry>
                <entry>
                  <para>Used internaly in creating of a poster.</para>
                  <para>PosterZ=-1: Render the bitmap above the given bounds.</para>
                  <para>PosterZ=1: Render the bitmap below the given bounds.</para>
                </entry>
              </row>
              <row>
                <entry>View.PosterX</entry>
                <entry>
                  <para>Used internally in creating a poster.</para>
                  <para>PosterX=-1: Render the bitmap left the given bounds.</para>
                  <para>PosterX=1: Render the bitmap right the given bounds.</para>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </chapter>
  </part>
</book>